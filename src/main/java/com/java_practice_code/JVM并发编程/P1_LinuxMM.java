package com.java_practice_code.JVM并发编程;

/**
 * linux下如何查看CPU内存模型的相关信息
 * https://www.cnblogs.com/kekukele/p/3829369.html
 * https://blog.csdn.net/wangquan1992/article/details/103821138
 * https://blog.csdn.net/u013920085/article/details/50010925
 */

public class P1_LinuxMM {
    /**
     * 问题1：什么是CPU内存模型， 什么是JMM， JMM与CPU内存模型的关系？
     * 答：首先说为什么有CPU内存模型，
     *    1、我们需要知道一个事实，那就是CPU的运算速度与主内存的运算速度差了几个数量级，如果不加任何手段的话这会严重拖慢CPU的运算速度。
     *    于是人们就在CPU与主内存之间加入了一层缓存，这个缓存虽然比CPU慢，但至少比主内存都快。有的CPU可能还与主内存隔了几层缓存。
     *    这会使得CPU运算速度提高，但是同时也为计算机带来了更高的复杂度，需要额外处理CPU缓存中的数据，需要处理CPU缓存一致性的问题等等。
     *    虽然CPU的厂商会解决这些问题，但是不同的CPU厂商这些CPU的内存模型可能不太一样，所以像C/C++程序员在编写业务逻辑代码的时候还需要
     *    关心不同厂商的CPU带来的差异，通过代码自己去屏蔽这些底层的差异。
     *
     *    2、而Java面世之初便号称跨平台，如果不解决这些问题还怎么称作跨平台呢？
     *    于是，Java有自己的一套内存模型，叫做JMM（Java Memory Model），JMM是对CPU内存模型的抽象，
     *    JMM内存模型有两种组件，分别是主内存和工作内存
     *    向上为Java程序员提供了一个统一、标准化的内存模型，向下屏蔽了不同厂商不同型号的CPU内存模型的访问细节，
     *    为Java的跨平台提供条件，JMM描述的是多线程与内存间的通信。
     *
     *    3、JMM与CPU内存模型的关系：JMM是对不同CPU内存模型的一个抽象，一个标准化接口。
     *
     * 问题2：JMM与Java内存分区的关系，例如JMM与线程栈，堆之间的关系，是否有映射关系？
     * 答：JMM与Java的内存分区（堆，栈，方法区）不是同一个东西。不是同一个维度的内存划分。这两者基本上没有任何关系。
     *    1、Java内存分区描述的是什么数据应该放在什么地方，线程私有的数据放在线程栈中，new出来的对象放在堆中，方法区存放一些类信息等等。
     *    2、而JMM描述的是数据是如何从主内存加载到CPU缓存的，或者数据是如何从CPU缓存写回主内存的；然后如何保证数据在各个CPU缓存中的一致性等等。
     *    而这个数据呢有可能是堆中的数据，也有可能是栈中的数据，也有可能是方法区中的数据。
     *    3、比如说代码在运行时需要用到某个线程栈中的变量A，此时这个A可能位于主内存中
     *    （因为有可能这个线程栈的数据太多，工作内存放不下就把A这个数据放到主内存中；或者线程刚刚切换需要从主内存中恢复现场），
     *    需要将A从主内存加载到工作内存；又或者说代码在运行时需要用到堆中某个变量B，此时这个B可能位于主内存中，需要将B从主内存加载到工作内存；
     *    JMM描述的就是这个将数据从主内存加载到工作内存过程。
     *
     *
     * 问题3：JMM中有8大原子指令，分别是lock,unlock,read,load,use,assign,store,write;
     * 其中读取数据时需要先read然后在load，写回数据时需要先store再write，为什么读取和写入分别都需要两步操作呢？不能够简化程一步吗？
     * 答：
     *
     * 问题4：JMM模型如何映射到CPU内存模型？JMM模型的那一部分分别对应CPU内存模型那一部分？
     */
}
